#version 450

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba32f, binding = 0) uniform image2D output_image;

#define MAX_STEPS 100
#define MAX_DIST 100.0
#define SURFACE_DIST 0.01

layout(std430, binding = 1) buffer voxel_data {
    ivec4 data[];
};
uniform ivec3 u_VolumeDimension;

// Camera
uniform mat4 uClipToCamera;
uniform mat4 uCameraToWorld;

uniform float uTime;

float sdSphere(vec3 p, float radius) {
    return length(p) - radius;
}

float scene(vec3 p) {
    return sdSphere(p, 1.0);
}

float raymarch(vec3 ro, vec3 rd) {
    float dO = 0.0;
    vec3 color = vec3(0.0);

    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 p = ro + rd * dO;

        float dS = scene(p);
        dO += dS;

        if (dO > MAX_DIST || dS < SURFACE_DIST) {
            break;
        }
    }
    return dO;
}

void main() {
    vec3 pixel_color = vec3(0.f);
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy); // Current pixel position in window space
    ivec2 image_dims = imageSize(output_image); // Window size
    vec2 uv = (pixel_coords - .5 * image_dims) / image_dims;

    vec3 ro = (uCameraToWorld * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
    vec3 rd = normalize(uClipToCamera * vec4(uv.x, uv.y, 1., 1.0)).xyz;
    rd = normalize((uCameraToWorld * vec4(rd, 0.0)).xyz);

    float d = raymarch(ro, rd);
    vec3 p = ro + rd * d;

    if (d < MAX_DIST) {
        pixel_color = vec3(1.0, 1.0, 1.0);
    }

    imageStore(output_image, pixel_coords, vec4(pixel_color, 1.0f));
}
